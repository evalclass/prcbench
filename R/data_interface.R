#' Create a list of test datasets
#'
#' The \code{create_testset} function creates various types of test datasets.
#'
#' @param test_type A single string to specify the type of dataset generated by
#'   this function.
#'
#'   \describe{
#'     \item{"bench"}{Create test datasets for benchmarking}
#'     \item{"curve"}{Create test datasets for curve evaluation}
#'     \item{"single"}{Create a single test dataset}
#'   }
#'
#' @param set_names A character vector to specify the names of predefined test
#'   datasets.
#'
#' \enumerate{
#'
#'   \item For benchmarking (\code{test_type = "bench"})
#'
#'   This function uses a name convension for randomly generated data. The
#'   format is a prefix ('i' or 'b') followed by the number of dataset. The
#'   prefix 'i' indicates a balanced dataset, whereas 'b' indicates an
#'   imbalanced dataset. The number can be used with a suffix 'k' or 'm',
#'   indicating respectively 1000 or 1 million.
#'
#'   Below are some examples.
#'   \describe{
#'     \item{"b100"}{A balanced data set with 50 positives and 50
#'         negatives.}
#'     \item{"b10k"}{A balanced data set with 5000 positives and 5000
#'         negatives.}
#'     \item{"b1m"}{A balanced data set with 500,000 positives and 500,000
#'         negatives.}
#'     \item{"i100"}{An imbalanced data set with 25 positives and 75
#'         negatives.}
#'   }
#'
#'   The function returns a list of \code{\link{TestDataPB}} objects.
#'
#'   \item For curve evaluation (\code{test_type = "curve"})
#'
#'   The following three predifned datasets can be specified.
#'
#'   \tabular{lll}{
#'     \strong{samp_name}
#'     \tab \strong{\code{S3} object}
#'     \tab \strong{data source} \cr
#'
#'     p1 or P1 \tab \code{\link{TestDataEC}} \tab \code{\link{P1DATA}}   \cr
#'     p2 or P2 \tab \code{\link{TestDataEC}} \tab \code{\link{P2DATA}}   \cr
#'     p3 or P3 \tab \code{\link{TestDataEC}} \tab \code{\link{P3DATA}}
#'   }
#'
#'   The function returns a list of \code{\link{TestDataEC}} objects.
#' }
#'
#' @param dsname A single string to specify the name of the dataset.
#'
#' @param scores A numeric vector to set scores.
#'
#' @param labels A numeric vector to set labels.
#'
#' @param base_x A numeric vector to set precalculated recall values for
#'    curve evaulation.
#'
#' @param base_y A numeric vector to set precalculated precision values for
#'    curve evaulation.
#'
#' @param text_x A single numeric value to set the x position for displaying
#'    the test result in a plot
#'
#' @param text_y A single numeric value to set the y position for displaying
#'    the test result in a plot
#'
#' @return A list of \code{R6} test dataset objects.
#'
#' @seealso \code{\link{run_benchmark}} and \code{\link{run_evalcurve}} require
#'  the list of the datasets generated by this funciton.
#'  \code{\link{TestDataPB}} for benchmarking testdata.
#'  \code{\link{TestDataEC}}, \code{\link{P1DATA}}, \code{\link{P2DATA}},
#'  and \code{\link{P3DATA}} for curve evaluation testdata.
#'
#' @examples
#' ## Create a balanced data set with 50 positives and 50 negatives
#' tset1 <- create_testset("bench", "b100")
#'
#' ## Create an imbalanced data set with 25 positives and 75 negatives
#' tset2 <- create_testset("bench", "i100")
#'
#' ## Create P1 dataset
#' tset3 <- create_testset("curve", "p1")
#'
#' ## Create P1 dataset
#' tset4 <- create_testset("curve", c("p1", "p2"))
#'
#' @export
create_testset <- function(test_type, set_names = NULL, scores = NULL,
                           labels = NULL, dsname = NA, base_x = NULL,
                           base_y = NULL, text_x = NULL, text_y = NULL) {

  if (!is.na(pmatch(test_type, "single"))) {
    set_names <- "single"
    if (!is.null(base_x) && !is.null(base_y)) {
      ds <- TestDataEC$new(scores, labels, dsname)
      ds$set_basepoints_x(base_x)
      ds$set_basepoints_y(base_y)
      if (!is.null(text_x)) {
        ds$set_textpos_x(text_x)
      }
      if (!is.null(text_y)) {
        ds$set_textpos_y(text_y)
      }
      dsets <- list(ds)
    } else {
      dsets <- list(TestDataPB$new(scores, labels, dsname))
    }
  } else if (!is.na(pmatch(test_type, "bench"))) {
    dsets <- lapply(set_names, function(sname) {.create_rsample(sname)})
  } else if (!is.na(pmatch(test_type, "curve"))) {
    dsets <- lapply(set_names, function(sname) {.create_precalc(sname)})
  }

  names(dsets) <- set_names
  dsets
}

#
# Create a random sample dataset
#
.create_rsample <- function(sname = NULL, np = 10, pfunc = NULL, nn = 10,
                            nfunc = NULL) {

  # Calculate np and nn when sename is specified
  if (!is.null(sname)) {
    tot <- as.numeric(gsub("[i|b|k|m]", "", tolower(sname)))
    if (grepl("k$", tolower(sname))) {
      tot <- tot * 1000
    } else if (grepl("m$", tolower(sname))) {
      tot <- tot * 1000 * 1000
    }

    if (grepl("^i", tolower(sname))) {
      posratio <- 0.25
    } else if (grepl("^b", tolower(sname))) {
      posratio <- 0.5
    } else {
      posratio <- runif(1)
    }

    np <- round(tot * posratio)
    nn <- tot - np
  }

  # Sample positive scores
  if (is.null(pfunc)) {
    pfunc = function(n) stats::rbeta(n, shape1 = 1, shape2 = 1)
  }

  # Sample negative scores
  if (is.null(nfunc)) {
    nfunc = function(n) stats::rbeta(n, shape1 = 1, shape2 = 4)
  }

  # Create scores and labels
  scores <- c(pfunc(np), nfunc(nn))
  labels <- c(rep(1, np), rep(0, nn))

  # Create a TestDataPB object
  TestDataPB$new(scores, labels, as.character(sname))
}

#
# Get a test dataset with precalculated values
#
.create_precalc <- function(sname) {
  if (tolower(sname) == "p1") {
    pdata <- prcbench::P1DATA
  } else if (tolower(sname) == "p2") {
    pdata <- prcbench::P2DATA
  } else if (tolower(sname) == "p3") {
    pdata <- prcbench::P3DATA
  } else {
    stop("Ivalid dataset name")
  }

  # Create a TestDataEC object
  ds <- TestDataEC$new(pdata$scores, pdata$labels, sname)
  ds$set_basepoints_x(pdata$bp_x)
  ds$set_basepoints_y(pdata$bp_y)
  ds$set_textpos_x(pdata$tp_x)
  ds$set_textpos_y(pdata$tp_y)

  ds
}
